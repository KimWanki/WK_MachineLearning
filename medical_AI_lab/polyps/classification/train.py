# conda activate wkkim

import os, numpy as np
import matplotlib.pyplot as plt
import imgaug.augmenters as iaa
import cv2
# apply augmenters in random order

# seq = iaa.Sequential([
#     # iaa.imgcorruptlike.Snow(severity=1)
#     iaa.imgcorruptlike.Spatter(severity=1)
# ], random_order=True)
# def aug_generator(batches):
#     """Take as input a Keras ImageGen (Iterator) and generate random
#     crops from the image batches generated by the original iterator.
#     """
#     # batch_x, batch_y = next(batches)
#     # for i in index(batch_x):
#     # batch_x[0] = cv2.cvtColor(batch_x[0],cv2.COLOR_BGRA2RGB)
#     while True:
#         batch_x, batch_y = next(batches)
#         for i in range(batch_x.shape[0]):
#             batch_x[i] = seq(images=batch_x[i].astype(np.uint8))
#         yield (batch_x, batch_y)

os.environ["CUDA_DEVICE_ORDER"] = "PCI_BUS_ID"
os.environ["CUDA_VISIBLE_DEVICES"] = "0"

from classification_models.keras import Classifiers
from keras.layers import GlobalAveragePooling2D, Dense
from keras.models import Model

Vgg16, preprocess_input = Classifiers.get('vgg16')

n_classes = 4

# build model
base_model = Vgg16(input_shape=(320, 320, 3), weights='imagenet', include_top=False)

for layer in base_model.layers:
    layer.trainable = True

x = GlobalAveragePooling2D()(base_model.output)
output = Dense(n_classes, activation='softmax')(x)
model = Model(inputs=base_model.input, outputs=output)

from keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=40,
    width_shift_range=0.15,
    height_shift_range=0.15,
    zoom_range=0.3,
    horizontal_flip=True,
    vertical_flip=True,
    brightness_range=[0.8, 1.3],
    # channel_shift_range=100,
    preprocessing_function=preprocess_input,
    fill_mode='constant'
)

train_generator = train_datagen.flow_from_directory(
    directory='C:/Users/user/Desktop/wkkim/classification/dataset/train',
    target_size=(320, 320),
    batch_size=10,
    color_mode='rgb',
    class_mode='categorical',
    shuffle=True
)
x_train, y_train = train_generator.next()
print(len(x_train))
for idx in range(len(x_train)):
    print(x_train[idx].shape)
    print(y_train[idx])
    plt.imshow(x_train[idx])
    plt.show()

plt.imshow(train_generator[0][0])
plt.show()


# train_generator = aug_generator(train_generator)
val_datagen = ImageDataGenerator(
    preprocessing_function=preprocess_input
)

val_generator = val_datagen.flow_from_directory(
    directory='C:/Users/user/Desktop/wkkim/classification/dataset/val',
    target_size=(320, 320),
    batch_size=10,
    class_mode='categorical',
    shuffle=False
)

from keras import optimizers
model.compile(optimizer=optimizers.Adam(lr=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])

from keras.callbacks import ModelCheckpoint
checkpoint = ModelCheckpoint('/home/wkkim/intestineDataset/classification/Vgg16.h5',
                             save_best_only=True, monitor='val_accuracy', verbose=1, save_weights_only=False,
                             mode='auto', period=1)
import math
callback_list = [checkpoint]
result = model.fit_generator(train_generator, steps_per_epoch=math.ceil(2704 / 10),
                             epochs=100,
                             callbacks=callback_list,
                             validation_data=val_generator,
                             validation_steps=30,
                             shuffle=True)

# test_datagen = ImageDataGenerator(
#     preprocessing_function=preprocess_input
# )

# test_generator = val_datagen.flow_from_directory(
#     directory= 'C:/Users/USER/Desktop/wkkim/classification/dataset/test',
#     target_size=(320, 320),
#     batch_size=10,
#     class_mode='categorical',
#     shuffle=False
# )

# model.load_weights('C:/Users/USER/PycharmProjects/2020intern_1/medicalAI/classfication_models_keras/model/DenseNet121_320.h5')
# scores = model.evaluate_generator(test_datagen)

# print("Loss: {:.5}".format(scores[0]))
# for metric, value in zip(metrics, scores[1:]):
#     print("mean {}: {:.5}".format(metric.__name__, value))
